<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<meta name="theme-color" content="#ff6b9d">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title" content="Chat-APP Pro">
<title>Chat-APP Pro v4.1</title>

<link rel="manifest" href="data:application/json;base64,eyJuYW1lIjoiQ2hhdC1BUFAgUHJvIiwic2hvcnRfbmFtZSI6IkNoYXQiLCJkZXNjcmlwdGlvbiI6IlByb2Zlc3Npb25hbCBjaGF0IGFwcCIsInN0YXJ0X3VybCI6Ii4vIiwiZGlzcGxheSI6InN0YW5kYWxvbmUiLCJiYWNrZ3JvdW5kX2NvbG9yIjoiI2ZlZjNmOCIsInRoZW1lX2NvbG9yIjoiI2ZmNmI5ZCIsIm9yaWVudGF0aW9uIjoicG9ydHJhaXQiLCJpY29ucyI6W3sic3JjIjoiZGF0YTppbWFnZS9zdmcreG1sLCUzQ3N2ZyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIHdpZHRoPScxOTInIGhlaWdodD0nMTkyJyUzRSUzQ3JlY3Qgd2lkdGg9JzE5MicgaGVpZ2h0PScxOTInIGZpbGw9JyUyM2ZmNmI5ZCcvJTNFJTNDdGV4dCB4PSc1MCUyNScgeT0nNTAlMjUnIGZvbnQtc2l6ZT0nOTAnIHRleHQtYW5jaG9yPSdtaWRkbGUnIGR5PScuMzVlbScgZmlsbD0nd2hpdGUnJTNFJUYwJTlGJTkyJUFDJTNDL3RleHQlM0UlM0Mvc3ZnJTNFIiwic2l6ZXMiOiIxOTJ4MTkyIiwidHlwZSI6ImltYWdlL3N2Zyt4bWwiLCJwdXJwb3NlIjoiYW55IG1hc2thYmxlIn0seyJzcmMiOiJkYXRhOmltYWdlL3N2Zyt4bWwsJTNDc3ZnIHhtbG5zPSdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Zycgd2lkdGg9JzUxMicgaGVpZ2h0PSc1MTInJTNFJTNDcmVjdCB3aWR0aD0nNTEyJyBoZWlnaHQ9JzUxMicgZmlsbD0nJTIzZmY2YjlkJy8lM0UlM0N0ZXh0IHg9JzUwJTI1JyB5PSc1MCUyNScgZm9udC1zaXplPScyNDAnIHRleHQtYW5jaG9yPSdtaWRkbGUnIGR5PScuMzVlbScgZmlsbD0nd2hpdGUnJTNFJUYwJTlGJTkyJUFDJTNDL3RleHQlM0UlM0Mvc3ZnJTNFIiwic2l6ZXMiOiI1MTJ4NTEyIiwidHlwZSI6ImltYWdlL3N2Zyt4bWwifV19">

<script src="https://cdn.pubnub.com/sdk/javascript/pubnub.8.2.7.min.js"></script>
<link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600;700&display=swap" rel="stylesheet">

<style>
:root{--bg1:#fef3f8;--bg2:#fff;--bg3:#ffe8f3;--tx1:#2d1b3d;--tx2:#7d5a8f;--tx3:#b399c2;--ac1:#ff6b9d;--ac2:#c44569;--bdr:#ffd1e3}
body[data-accent=pink]{--ac1:#ff6b9d;--ac2:#c44569}
body[data-accent=purple]{--ac1:#a855f7;--ac2:#7c3aed}
body[data-accent=blue]{--ac1:#3b82f6;--ac2:#2563eb}
body[data-accent=green]{--ac1:#10b981;--ac2:#059669}
body[data-accent=orange]{--ac1:#f97316;--ac2:#ea580c}
body[data-accent=red]{--ac1:#ef4444;--ac2:#dc2626}
body[data-accent=cyan]{--ac1:#06b6d4;--ac2:#0891b2}
body[data-accent=indigo]{--ac1:#6366f1;--ac2:#4f46e5}
body.dark{--bg1:#1a0d2e;--bg2:#2d1b3d;--bg3:#3d2651;--tx1:#fef3f8;--tx2:#d4a5c9;--tx3:#9d7ba8;--bdr:#4a3258}
*{margin:0;padding:0;box-sizing:border-box;-webkit-tap-highlight-color:transparent}
body{font-family:Poppins,sans-serif;background:var(--bg1);color:var(--tx1);height:100vh;overflow:hidden;position:fixed;width:100%;transition:all .3s ease}
.hide{display:none!important}
#login{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:linear-gradient(135deg,#ff6b9d,#c44569,#8e44ad);padding:24px}
.login-card{background:var(--bg2);padding:48px 40px;border-radius:28px;box-shadow:0 10px 30px rgba(0,0,0,.3);text-align:center;max-width:420px;width:100%}
.app-icon{width:88px;height:88px;background:linear-gradient(135deg,#ff6b9d,#c44569);border-radius:22px;margin:0 auto 24px;display:flex;align-items:center;justify-content:center;font-size:50px;box-shadow:0 8px 20px rgba(196,69,105,.4)}
.login-title{font-size:34px;font-weight:700;background:linear-gradient(135deg,#ff6b9d,#c44569);-webkit-background-clip:text;-webkit-text-fill-color:transparent;margin-bottom:12px}
.login-subtitle{color:var(--tx2);margin-bottom:32px;font-size:15px}
.user-btn{width:100%;padding:18px;margin:12px 0;border:0;border-radius:18px;background:linear-gradient(135deg,#ff6b9d,#c44569);color:#fff;font-size:17px;font-weight:600;cursor:pointer;display:flex;align-items:center;justify-content:center;gap:14px;box-shadow:0 6px 16px rgba(255,107,157,.4);transition:transform .2s}
.user-btn:active{transform:scale(.96)}
.user-avatar{width:38px;height:38px;background:rgba(255,255,255,.28);border-radius:50%;display:flex;align-items:center;justify-content:center;font-weight:700}
.pwa-install{position:fixed;bottom:24px;right:24px;width:64px;height:64px;background:linear-gradient(135deg,#ff6b9d,#c44569);border:0;border-radius:50%;color:#fff;font-size:28px;cursor:pointer;box-shadow:0 6px 24px rgba(255,107,157,.5);display:none;z-index:9999;transition:all .2s;align-items:center;justify-content:center}
.pwa-install:active{transform:scale(.92)}
.pwa-install.show{display:flex;animation:bounce 2s infinite}
@keyframes bounce{0%,20%,50%,80%,100%{transform:translateY(0)}40%{transform:translateY(-12px)}60%{transform:translateY(-6px)}}
#chat{position:fixed;inset:0;background:var(--bg1);padding:12px}
.chat-container{height:100%;max-width:720px;margin:0 auto;background:var(--bg2);border:2px solid var(--bdr);border-radius:24px;display:flex;flex-direction:column;overflow:hidden;box-shadow:0 10px 30px rgba(255,107,157,.2)}
.header{background:linear-gradient(135deg,var(--ac1),var(--ac2));padding:18px 20px;display:flex;align-items:center;gap:14px;color:#fff}
.header-avatar{width:46px;height:46px;background:rgba(255,255,255,.28);border:2px solid rgba(255,255,255,.5);border-radius:50%;display:flex;align-items:center;justify-content:center;font-weight:700;font-size:18px}
.header-info{flex:1}
.header-title{font-weight:700;font-size:18px}
.header-status{font-size:13px;opacity:.92;margin-top:2px}
.header-btn{width:42px;height:42px;border:0;background:rgba(255,255,255,.22);color:#fff;border-radius:11px;font-size:19px;cursor:pointer;transition:transform .2s}
.header-btn:active{transform:scale(.92)}
.messages{flex:1;overflow-y:auto;padding:20px;background:var(--bg1);display:flex;flex-direction:column;gap:13px}
.messages::-webkit-scrollbar{width:6px}
.messages::-webkit-scrollbar-thumb{background:var(--ac1);border-radius:3px}
.new-messages-badge{position:sticky;top:0;background:var(--ac1);color:#fff;padding:8px 16px;border-radius:20px;margin:10px auto;font-size:13px;font-weight:600;cursor:pointer;box-shadow:0 4px 12px rgba(255,107,157,.4);animation:slideDown .3s ease;z-index:100}
.date-divider{display:flex;justify-content:center;margin:18px 0}
.date-label{background:var(--bg3);border:1px solid var(--bdr);padding:5px 13px;border-radius:12px;font-size:12px;font-weight:600;color:var(--tx2);text-transform:uppercase;letter-spacing:.5px}
.msg{max-width:76%;animation:pop .3s ease;transition:background-color .5s ease}
.msg.highlighted{background:rgba(255,107,157,.1);border-radius:12px;padding:4px}
@keyframes pop{0%{opacity:0;transform:scale(.85) translateY(15px)}100%{opacity:1;transform:scale(1) translateY(0)}}
.me{align-self:flex-end}
.you{align-self:flex-start}
.bubble{padding:13px 17px;border-radius:17px;font-size:15px;line-height:1.55;white-space:pre-wrap;word-wrap:break-word;font-weight:500;cursor:pointer;transition:transform .1s;position:relative}
.bubble:active{transform:scale(.98)}
.me .bubble{background:linear-gradient(135deg,var(--ac1),var(--ac2));color:#fff;border-bottom-right-radius:5px;box-shadow:0 4px 14px rgba(255,107,157,.38)}
.you .bubble{background:var(--bg2);border:2px solid var(--bdr);color:var(--tx1);border-bottom-left-radius:5px;box-shadow:0 2px 8px rgba(255,107,157,.12)}
.bubble.deleted{background:transparent!important;border:2px dashed var(--ac1)!important;color:var(--tx3)!important;font-style:italic;opacity:.7}
.link-preview{background:rgba(0,0,0,.05);border:1px solid var(--bdr);border-radius:8px;padding:8px 12px;margin-top:8px;display:flex;align-items:center;gap:8px;font-size:13px}
.link-icon{width:16px;height:16px;opacity:.7}
.link-domain{color:var(--ac1);font-weight:600}
.reactions{display:flex;gap:4px;margin-top:6px;flex-wrap:wrap}
.reaction{background:rgba(255,255,255,.2);border:1px solid rgba(255,255,255,.3);border-radius:12px;padding:2px 6px;font-size:12px;display:flex;align-items:center;gap:2px;cursor:pointer;transition:all .2s}
.you .reaction{background:var(--bg3);border:1px solid var(--bdr);color:var(--tx2)}
.reaction:active{transform:scale(.9)}
.reaction.reacted{background:var(--ac1);color:#fff;border-color:var(--ac1)}
.msg-time{font-size:11px;margin-top:6px;text-align:right;opacity:.83;display:flex;align-items:center;justify-content:flex-end;gap:4px}
.me .msg-time{color:rgba(255,255,255,.95)}
.you .msg-time{color:var(--tx3)}
.checks{font-size:13px;font-weight:bold;transition:color .2s}
.checks.sent{color:#999}
.checks.delivered{color:#999}
.checks.read{color:#4fc3f7}
.reply-preview{background:rgba(0,0,0,.1);border-left:4px solid currentColor;padding:9px 11px;margin-bottom:9px;border-radius:10px;font-size:13px;cursor:pointer;transition:background .2s}
.me .reply-preview{background:rgba(255,255,255,.22)}
.reply-preview:hover{background:rgba(0,0,0,.15)}
.me .reply-preview:hover{background:rgba(255,255,255,.3)}
.reply-name{font-weight:700;margin-bottom:4px}
.reply-text{opacity:.87;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
.typing{padding:0 20px;min-height:26px;font-size:13px;color:var(--ac1);font-style:italic;font-weight:600;display:flex;align-items:center}
.typing.active{animation:pulse 1.5s infinite}
@keyframes pulse{0%,100%{opacity:1}50%{opacity:.6}}
.reply-bar{display:none;background:linear-gradient(90deg,var(--ac1),var(--ac2));color:#fff;padding:11px 20px;position:relative;font-size:14px}
.reply-bar.show{display:block}
.reply-bar-name{font-weight:700;margin-bottom:4px}
.reply-bar-text{opacity:.88;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;padding-right:42px}
.reply-close{position:absolute;right:14px;top:50%;transform:translateY(-50%);width:30px;height:30px;border:0;background:rgba(255,255,255,.22);color:#fff;border-radius:50%;font-size:21px;cursor:pointer;line-height:1}
.input-area{border-top:2px solid var(--bdr);padding:17px 20px;display:flex;gap:11px;align-items:flex-end;background:var(--bg2)}
textarea{flex:1;min-height:49px;max-height:130px;padding:13px 17px;border:2px solid var(--bdr);border-radius:17px;font-family:inherit;font-size:15px;resize:none;background:var(--bg3);color:var(--tx1);font-weight:500;transition:all .2s}
textarea:focus{outline:0;border-color:var(--ac1);background:var(--bg2);box-shadow:0 0 0 4px rgba(255,107,157,.1)}
.send{width:49px;height:49px;border:0;border-radius:50%;background:linear-gradient(135deg,var(--ac1),var(--ac2));color:#fff;font-size:21px;cursor:pointer;box-shadow:0 4px 14px rgba(255,107,157,.42);display:flex;align-items:center;justify-content:center;transition:transform .2s}
.send:active{transform:scale(.88)}
.send:disabled{opacity:.42;cursor:not-allowed}
.menu{position:fixed;background:var(--bg2);border:2px solid var(--bdr);border-radius:15px;box-shadow:0 10px 30px rgba(0,0,0,.25);min-width:170px;display:none;flex-direction:column;z-index:1000;overflow:hidden}
.menu.show{display:flex;animation:menuPop .2s ease}
@keyframes menuPop{0%{opacity:0;transform:scale(.92)}100%{opacity:1;transform:scale(1)}}
.menu button{padding:15px 20px;border:0;background:0;text-align:left;font-size:15px;font-weight:600;cursor:pointer;color:var(--tx1);display:flex;align-items:center;gap:12px;transition:background .2s}
.menu button:active{background:var(--bg3)}
.menu button.danger{color:#ef4444}
.emoji-picker{position:fixed;bottom:80px;right:20px;background:var(--bg2);border:2px solid var(--bdr);border-radius:12px;padding:16px;display:none;z-index:1500;box-shadow:0 10px 30px rgba(0,0,0,.25)}
.emoji-picker.show{display:block;animation:slideUp .2s ease}
.emoji-grid{display:grid;grid-template-columns:repeat(6,1fr);gap:8px}
.emoji-btn{width:32px;height:32px;border:0;background:0;font-size:18px;border-radius:6px;cursor:pointer;transition:background .2s}
.emoji-btn:hover{background:var(--bg3)}
.dialog-overlay{position:fixed;inset:0;background:rgba(0,0,0,.65);display:none;align-items:center;justify-content:center;z-index:2000;padding:22px;backdrop-filter:blur(5px)}
.dialog-overlay.show{display:flex;animation:fadeIn .25s ease}
@keyframes fadeIn{from{opacity:0}to{opacity:1}}
.dialog-card{background:var(--bg2);padding:28px;border-radius:22px;max-width:400px;width:100%;border:2px solid var(--bdr);box-shadow:0 10px 30px rgba(0,0,0,.3);animation:slideUp .3s ease}
@keyframes slideUp{from{opacity:0;transform:translateY(25px) scale(.96)}to{opacity:1;transform:translateY(0) scale(1)}}
.dialog-title{font-size:22px;font-weight:700;background:linear-gradient(135deg,var(--ac1),var(--ac2));-webkit-background-clip:text;-webkit-text-fill-color:transparent;margin-bottom:12px}
.dialog-message{color:var(--tx2);margin-bottom:22px;line-height:1.65;font-size:15px}
.dialog-actions{display:flex;gap:11px;justify-content:flex-end}
.dialog-btn{padding:13px 26px;border:0;border-radius:13px;font-weight:600;cursor:pointer;font-size:15px;transition:transform .2s}
.dialog-btn-cancel{background:var(--bg3);border:2px solid var(--bdr);color:var(--tx1)}
.dialog-btn-primary{background:linear-gradient(135deg,var(--ac1),var(--ac2));color:#fff;box-shadow:0 4px 12px rgba(255,107,157,.35)}
.dialog-btn-danger{background:linear-gradient(135deg,#ef4444,#dc2626);color:#fff;box-shadow:0 4px 12px rgba(239,68,68,.35)}
.dialog-btn:active{transform:scale(.94)}
.settings-card{max-height:80vh;overflow-y:auto}
.settings-section{margin-bottom:32px}
.settings-section-title{font-size:13px;font-weight:700;color:var(--ac1);text-transform:uppercase;letter-spacing:1px;margin-bottom:16px}
.setting-option{padding:18px 0;border-bottom:1px solid var(--bdr);display:flex;align-items:center;justify-content:space-between;gap:16px}
.setting-option:last-child{border-bottom:none}
.setting-label{font-size:16px;color:var(--tx1);font-weight:600}
.setting-desc{font-size:13px;color:var(--tx2);margin-top:5px;font-weight:500}
.toggle{position:relative;width:54px;height:30px;background:var(--bg3);border:2px solid var(--bdr);border-radius:15px;cursor:pointer;transition:all .3s}
.toggle.active{background:linear-gradient(135deg,var(--ac1),var(--ac2));border-color:var(--ac1)}
.toggle-knob{position:absolute;top:3px;left:3px;width:20px;height:20px;background:#fff;border-radius:50%;transition:all .3s;box-shadow:0 2px 6px rgba(0,0,0,.2)}
.toggle.active .toggle-knob{transform:translateX(24px)}
.color-grid{display:grid;grid-template-columns:repeat(2,1fr);gap:12px;margin-bottom:24px;padding:4px}
.color-option{padding:32px 20px;border-radius:12px;cursor:pointer;text-align:center;border:3px solid transparent;transition:all .2s}
.color-option.selected{border-color:#fff;box-shadow:0 0 0 4px var(--bg2);transform:scale(1.05)}
.color-name{color:#fff;font-weight:700;font-size:15px}
.notification{position:fixed;top:22px;left:50%;transform:translateX(-50%);background:var(--bg2);border:2px solid var(--bdr);padding:13px 26px;border-radius:14px;box-shadow:0 6px 20px rgba(0,0,0,.25);display:none;z-index:3000;font-weight:600;color:var(--tx1);font-size:14px;max-width:90%}
.notification.show{display:block;animation:slideDown .3s ease}
@keyframes slideDown{from{opacity:0;transform:translate(-50%,-25px)}to{opacity:1;transform:translate(-50%,0)}}
@media(max-width:640px){.messages::-webkit-scrollbar{display:none}}
@media(display-mode:standalone){.pwa-install{display:none!important}}
</style>
</head>

<body data-accent="pink">

<div id="login">
  <div class="login-card">
    <div class="app-icon">💬</div>
    <h1 class="login-title">Chat-APP Pro v4.1</h1>
    <p class="login-subtitle">Choose your account to continue</p>
    <button class="user-btn" data-user="aditya"><div class="user-avatar">A</div>Aditya</button>
    <button class="user-btn" data-user="vishwatej"><div class="user-avatar">V</div>Vishwatej</button>
  </div>
</div>

<div id="chat" class="hide">
  <div class="chat-container">
    <div class="header">
      <div class="header-avatar" id="headerAvatar">C</div>
      <div class="header-info">
        <div class="header-title">Chat Room</div>
        <div class="header-status" id="status">● Connecting...</div>
      </div>
      <button class="header-btn" id="settingsBtn">⚙️</button>
      <button class="header-btn" id="logoutBtn">⇦</button>
    </div>
    <div id="messages" class="messages"></div>
    <div id="typing" class="typing"></div>
    <div id="replyBar" class="reply-bar">
      <div class="reply-bar-name" id="replyName">User</div>
      <div class="reply-bar-text" id="replyText">Message</div>
      <button class="reply-close" id="replyClose">×</button>
    </div>
    <div class="input-area">
      <textarea id="input" placeholder="Type a message... (Shift+Enter to send)"></textarea>
      <button id="send" class="send" disabled>➤</button>
    </div>
  </div>
</div>

<button id="pwaInstall" class="pwa-install">📱</button>

<div id="menu" class="menu">
  <button id="mReply">💬 Reply</button>
  <button id="mCopy">📋 Copy</button>
  <button id="mReact">😊 React</button>
  <button id="mDelete" class="danger">🗑️ Delete</button>
</div>

<div id="emojiPicker" class="emoji-picker">
  <div class="emoji-grid">
    <button class="emoji-btn">👍</button>
    <button class="emoji-btn">❤️</button>
    <button class="emoji-btn">😂</button>
    <button class="emoji-btn">😮</button>
    <button class="emoji-btn">😢</button>
    <button class="emoji-btn">😡</button>
    <button class="emoji-btn">👏</button>
    <button class="emoji-btn">🔥</button>
    <button class="emoji-btn">🎉</button>
    <button class="emoji-btn">💯</button>
    <button class="emoji-btn">🙏</button>
    <button class="emoji-btn">🤝</button>
  </div>
</div>

<div id="deleteDialog" class="dialog-overlay">
  <div class="dialog-card">
    <div class="dialog-title">Delete message?</div>
    <div class="dialog-message">This message will be deleted for everyone in the chat. This action cannot be undone.</div>
    <div class="dialog-actions">
      <button class="dialog-btn dialog-btn-cancel" id="dialogDeleteCancel">Cancel</button>
      <button class="dialog-btn dialog-btn-danger" id="dialogDeleteConfirm">Delete</button>
    </div>
  </div>
</div>

<div id="logoutDialog" class="dialog-overlay">
  <div class="dialog-card">
    <div class="dialog-title">Logout?</div>
    <div class="dialog-message">Are you sure you want to logout?</div>
    <div class="dialog-actions">
      <button class="dialog-btn dialog-btn-cancel" id="dialogLogoutCancel">Cancel</button>
      <button class="dialog-btn dialog-btn-primary" id="dialogLogoutConfirm">Logout</button>
    </div>
  </div>
</div>

<div id="colorDialog" class="dialog-overlay">
  <div class="dialog-card">
    <div class="dialog-title">Choose Accent Color</div>
    <div class="dialog-message">Select your preferred accent color</div>
    <div class="color-grid">
      <div class="color-option selected" data-color="pink" style="background: linear-gradient(135deg, #ff6b9d 0%, #c44569 100%);"><span class="color-name">Pink</span></div>
      <div class="color-option" data-color="purple" style="background: linear-gradient(135deg, #a855f7 0%, #7c3aed 100%);"><span class="color-name">Purple</span></div>
      <div class="color-option" data-color="blue" style="background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);"><span class="color-name">Blue</span></div>
      <div class="color-option" data-color="green" style="background: linear-gradient(135deg, #10b981 0%, #059669 100%);"><span class="color-name">Green</span></div>
      <div class="color-option" data-color="orange" style="background: linear-gradient(135deg, #f97316 0%, #ea580c 100%);"><span class="color-name">Orange</span></div>
      <div class="color-option" data-color="red" style="background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);"><span class="color-name">Red</span></div>
      <div class="color-option" data-color="cyan" style="background: linear-gradient(135deg, #06b6d4 0%, #0891b2 100%);"><span class="color-name">Cyan</span></div>
      <div class="color-option" data-color="indigo" style="background: linear-gradient(135deg, #6366f1 0%, #4f46e5 100%);"><span class="color-name">Indigo</span></div>
    </div>
    <div class="dialog-actions">
      <button class="dialog-btn dialog-btn-cancel" id="dialogColorCancel">Cancel</button>
      <button class="dialog-btn dialog-btn-primary" id="dialogColorApply">Apply</button>
    </div>
  </div>
</div>

<div id="settingsDialog" class="dialog-overlay">
  <div class="dialog-card settings-card">
    <div class="dialog-title">Settings</div>
    <div class="settings-section">
      <div class="settings-section-title">Appearance</div>
      <div class="setting-option">
        <div style="flex: 1;">
          <div class="setting-label">Theme Mode</div>
          <div class="setting-desc">Switch between light and dark mode</div>
        </div>
        <div class="toggle" id="themeToggle">
          <div class="toggle-knob"></div>
        </div>
      </div>
      <div class="setting-option">
        <div style="flex: 1;">
          <div class="setting-label">Accent Color</div>
          <div class="setting-desc">Customize app theme color</div>
        </div>
        <button class="dialog-btn dialog-btn-primary" id="openColorDialog" style="min-width: 80px;">Choose</button>
      </div>
    </div>
    <div class="settings-section">
      <div class="settings-section-title">Notifications</div>
      <div class="setting-option">
        <div>
          <div class="setting-label">Sound</div>
          <div class="setting-desc">Play sound for new messages</div>
        </div>
        <div class="toggle" id="soundToggle">
          <div class="toggle-knob"></div>
        </div>
      </div>
      <div class="setting-option">
        <div>
          <div class="setting-label">Notifications</div>
          <div class="setting-desc">Show popup notifications</div>
        </div>
        <div class="toggle active" id="notifToggle">
          <div class="toggle-knob"></div>
        </div>
      </div>
      <div class="setting-option">
        <div>
          <div class="setting-label">Push Notifications</div>
          <div class="setting-desc">Get notified when app is closed</div>
        </div>
        <div class="toggle" id="pushToggle">
          <div class="toggle-knob"></div>
        </div>
      </div>
    </div>
    <div class="settings-section">
      <div class="settings-section-title">Behavior</div>
      <div class="setting-option">
        <div>
          <div class="setting-label">Auto-scroll</div>
          <div class="setting-desc">Scroll to new messages</div>
        </div>
        <div class="toggle active" id="scrollToggle">
          <div class="toggle-knob"></div>
        </div>
      </div>
    </div>
    <div class="dialog-actions" style="margin-top: 24px;">
      <button class="dialog-btn dialog-btn-primary" id="dialogSettingsClose" style="width: 100%;">Close</button>
    </div>
  </div>
</div>

<div id="notification" class="notification"></div>

<script>
console.log("🚀 Chat-APP Pro v4.1 - Loading...");

// SERVICE WORKER WITH BETTER PUSH NOTIFICATIONS
if ('serviceWorker' in navigator) {
  window.addEventListener('load', () => {
    const swCode = `
      const CACHE = 'chat-v4-1';
      const urlsToCache = ['/'];

      self.addEventListener('install', e => {
        console.log('SW: Installing v4.1...');
        e.waitUntil(
          caches.open(CACHE)
            .then(cache => cache.addAll(urlsToCache))
            .then(() => self.skipWaiting())
        );
      });

      self.addEventListener('activate', e => {
        console.log('SW: Activating v4.1...');
        e.waitUntil(clients.claim());
      });

      self.addEventListener('fetch', e => {
        e.respondWith(
          caches.match(e.request)
            .then(response => response || fetch(e.request))
        );
      });

      // ENHANCED PUSH NOTIFICATIONS
      self.addEventListener('push', e => {
        console.log('SW: Push received', e.data);

        let data = {};
        try {
          data = e.data ? e.data.json() : {};
        } catch (err) {
          console.log('SW: Push data parse error', err);
          data = { title: 'Chat-APP Pro', body: 'New message' };
        }

        const options = {
          body: data.body || 'New message received',
          icon: '/icon-192.png',
          badge: '/badge-96.png',
          vibrate: [200, 100, 200, 100, 200],
          tag: 'chat-message',
          renotify: true,
          requireInteraction: false,
          silent: false,
          data: data,
          actions: [
            {
              action: 'open',
              title: 'Open Chat',
              icon: '/icon-open.png'
            },
            {
              action: 'dismiss',
              title: 'Dismiss',
              icon: '/icon-close.png'
            }
          ]
        };

        e.waitUntil(
          self.registration.showNotification(data.title || 'Chat-APP Pro', options)
        );
      });

      self.addEventListener('notificationclick', e => {
        console.log('SW: Notification clicked', e);
        e.notification.close();

        if (e.action === 'dismiss') {
          return;
        }

        e.waitUntil(
          clients.matchAll({ type: 'window' })
            .then(clientList => {
              for (let client of clientList) {
                if (client.url.includes('chat') && 'focus' in client) {
                  return client.focus();
                }
              }
              if (clients.openWindow) {
                return clients.openWindow('/');
              }
            })
        );
      });

      self.addEventListener('notificationclose', e => {
        console.log('SW: Notification closed', e);
      });
    `;

    const blob = new Blob([swCode], { type: 'application/javascript' });
    const swUrl = URL.createObjectURL(blob);

    navigator.serviceWorker.register(swUrl)
      .then(reg => {
        console.log('✅ Service Worker registered', reg);
        if (Notification.permission === 'granted') {
          subscribeToPush(reg);
        }
      })
      .catch(err => {
        console.log('❌ Service Worker failed', err);
      });
  });
}

// PUSH NOTIFICATION SUBSCRIPTION
async function subscribeToPush(registration) {
  try {
    const subscription = await registration.pushManager.subscribe({
      userVisibleOnly: true,
      applicationServerKey: urlB64ToUint8Array('your-vapid-public-key-here')
    });
    console.log('✅ Push subscription:', subscription);
  } catch (err) {
    console.log('❌ Push subscription failed:', err);
  }
}

function urlB64ToUint8Array(base64String) {
  const padding = '='.repeat((4 - base64String.length % 4) % 4);
  const base64 = (base64String + padding).replace(/-/g, '+').replace(/_/g, '/');
  const rawData = window.atob(base64);
  const outputArray = new Uint8Array(rawData.length);
  for (let i = 0; i < rawData.length; ++i) {
    outputArray[i] = rawData.charCodeAt(i);
  }
  return outputArray;
}

// PWA INSTALL
let deferredPrompt = null;
const pwaBtn = document.getElementById('pwaInstall');

window.addEventListener('beforeinstallprompt', (e) => {
  console.log('🎯 PWA prompt available');
  e.preventDefault();
  deferredPrompt = e;
  pwaBtn.classList.add('show');
});

pwaBtn.addEventListener('click', async () => {
  if (!deferredPrompt) {
    notify('⚠️ Use browser menu: Add to Home Screen');
    return;
  }
  deferredPrompt.prompt();
  const result = await deferredPrompt.userChoice;
  if (result.outcome === 'accepted') {
    notify('✅ App installed!');
  }
  deferredPrompt = null;
  pwaBtn.classList.remove('show');
});

setTimeout(() => {
  const isStandalone = window.matchMedia('(display-mode: standalone)').matches;
  if (!isStandalone && !deferredPrompt) {
    pwaBtn.classList.add('show');
  }
}, 3000);

// ENHANCED NOTIFICATION PERMISSION
async function requestNotificationPermission() {
  if (!('Notification' in window)) {
    console.log('❌ Notifications not supported');
    return false;
  }

  if (Notification.permission === 'granted') {
    console.log('✅ Notification permission already granted');
    return true;
  }

  if (Notification.permission === 'denied') {
    console.log('❌ Notification permission denied');
    notify('❌ Notifications blocked. Enable in browser settings.');
    return false;
  }

  try {
    const permission = await Notification.requestPermission();
    if (permission === 'granted') {
      console.log('✅ Notification permission granted');
      notify('🔔 Notifications enabled!');

      const registration = await navigator.serviceWorker.ready;
      subscribeToPush(registration);

      return true;
    } else {
      console.log('❌ Notification permission denied');
      notify('❌ Notification permission denied');
      return false;
    }
  } catch (err) {
    console.log('❌ Notification permission error:', err);
    return false;
  }
}

function showDesktopNotification(title, body, icon) {
  if (Notification.permission === 'granted') {
    try {
      const notification = new Notification(title, {
        body: body,
        icon: icon || '/icon-192.png',
        vibrate: [200, 100, 200],
        tag: 'chat-message',
        renotify: true,
        silent: false
      });

      notification.onclick = () => {
        window.focus();
        notification.close();
      };

      setTimeout(() => notification.close(), 5000);

    } catch (err) {
      console.log('❌ Notification error:', err);
    }
  }
}

// PUBNUB CONFIG
const CONFIG = {
  publishKey: "pub-c-7a616042-44f7-4676-8e55-bcc9c12dc017",
  subscribeKey: "sub-c-96e9508a-dd7c-4241-9648-15195841b3f8",
  uuid: null,
  restore: false,
  heartbeatInterval: 0,
  suppressLeaveEvents: true,
  presenceTimeout: 0
};

const CHANNEL = "chat-room";
const CHANNEL_DELETE = "chat-room-deletes";
const CHANNEL_SIGNALS = "chat-room-signals";
const CHANNEL_REACTIONS = "chat-room-reactions";
const CHANNEL_RECEIPTS = "chat-room-receipts";
const ALLOWED = ["aditya", "vishwatej"];

const $ = id => document.getElementById(id);
const el = {
  login: $("login"), chat: $("chat"), messages: $("messages"), input: $("input"),
  send: $("send"), typing: $("typing"), replyBar: $("replyBar"), replyName: $("replyName"),
  replyText: $("replyText"), replyClose: $("replyClose"),
  menu: $("menu"), mReply: $("mReply"), mCopy: $("mCopy"),
  mReact: $("mReact"), mDelete: $("mDelete"), emojiPicker: $("emojiPicker"),
  deleteDialog: $("deleteDialog"), dialogDeleteCancel: $("dialogDeleteCancel"),
  dialogDeleteConfirm: $("dialogDeleteConfirm"), notification: $("notification"),
  status: $("status"), headerAvatar: $("headerAvatar"),
  logoutBtn: $("logoutBtn"), settingsBtn: $("settingsBtn"),
  settingsDialog: $("settingsDialog"), dialogSettingsClose: $("dialogSettingsClose"),
  soundToggle: $("soundToggle"), notifToggle: $("notifToggle"),
  pushToggle: $("pushToggle"), scrollToggle: $("scrollToggle"),
  openColorDialog: $("openColorDialog"), colorDialog: $("colorDialog"),
  dialogColorCancel: $("dialogColorCancel"), dialogColorApply: $("dialogColorApply"),
  logoutDialog: $("logoutDialog"), dialogLogoutCancel: $("dialogLogoutCancel"),
  dialogLogoutConfirm: $("dialogLogoutConfirm"), themeToggle: $("themeToggle")
};

const state = {
  user: null,
  pubnub: null,
  messages: new Map(),
  deletedIds: new Set(),
  messageReactions: new Map(),
  readReceipts: new Map(),
  replyTo: null,
  connected: false,
  typingUsers: new Set(),
  typingTimer: null,
  lastTypingSignal: 0,
  lastSendTime: 0,
  wasScrolledToBottom: true,
  currentMenuMessage: null,
  settings: {
    sound: false,
    notifications: true,
    pushNotifications: false,
    autoScroll: true,
    accentColor: "pink",
    darkMode: false
  }
};

document.querySelectorAll(".user-btn").forEach(btn => {
  btn.onclick = () => {
    const name = btn.dataset.user;
    if (!ALLOWED.includes(name)) {
      notify("❌ Access denied");
      return;
    }
    CONFIG.uuid = name;
    login(name);
  };
});

function login(name) {
  state.user = {
    name: name,
    displayName: name.charAt(0).toUpperCase() + name.slice(1)
  };

  localStorage.setItem("chatUser", JSON.stringify(state.user));
  el.headerAvatar.textContent = state.user.displayName.charAt(0);
  el.login.classList.add("hide");
  el.chat.classList.remove("hide");

  console.log("✅ Logged in as:", state.user.displayName);

  requestNotificationPermission();
  initPubNub();
}

function initPubNub() {
  try {
    console.log("🔧 Initializing PubNub...");

    state.pubnub = new PubNub(CONFIG);

    state.pubnub.addListener({
      status: s => {
        console.log("📡 Status:", s.category);

        if (s.category === "PNConnectedCategory") {
          state.connected = true;
          el.status.textContent = "● Online";
          console.log("✅ Connected!");
          notify("✅ Connected!");
          loadHistory();
          loadDeleteHistory();
          loadReactions();
        } else if (s.category === "PNAccessDeniedCategory") {
          console.error("❌ Access denied");
          el.status.textContent = "● Access Denied";
          notify("❌ Access denied");
        } else if (s.category === "PNNetworkDownCategory") {
          state.connected = false;
          el.status.textContent = "● Offline";
          notify("⚠️ Network offline");
        }
      },

      message: m => {
        try {
          const msg = m.message;
          if (!msg || !msg.id) return;

          msg.timetoken = m.timetoken;

          if (m.channel === CHANNEL_DELETE) {
            console.log("🗑️ Delete event:", msg.id);
            handleDelete(msg.id);
            return;
          }

          if (m.channel === CHANNEL_SIGNALS) {
            handleSignal(msg);
            return;
          }

          if (m.channel === CHANNEL_REACTIONS) {
            handleReaction(msg);
            return;
          }

          if (m.channel === CHANNEL_RECEIPTS) {
            handleReceipt(msg);
            return;
          }

          renderMessage(msg, true);

          if (msg.name !== state.user.name) {
            sendReceipt(msg.id, "delivered");

            if (state.settings.notifications) {
              notify(msg.displayName + ": " + msg.txt.substring(0, 30) + "...");
            }

            if (state.settings.pushNotifications || document.hidden) {
              showDesktopNotification(
                msg.displayName,
                msg.txt,
                '/icon-192.png'
              );
            }
          }

        } catch (error) {
          console.error("❌ Message handler error:", error);
        }
      }
    });

    state.pubnub.subscribe({ 
      channels: [CHANNEL, CHANNEL_DELETE, CHANNEL_SIGNALS, CHANNEL_REACTIONS, CHANNEL_RECEIPTS],
      withPresence: false
    });

    console.log("✅ Subscribed to all channels");

  } catch (error) {
    console.error("❌ PubNub init error:", error);
    notify("❌ Connection failed");
    el.status.textContent = "● Error";
  }
}

// ROBUST DELETE SYSTEM
function handleDelete(messageId) {
  state.deletedIds.add(messageId);

  const msg = state.messages.get(messageId);
  if (msg) {
    msg.deleted = true;
  }

  const node = el.messages.querySelector(`[data-id="${messageId}"] .bubble`);
  if (node) {
    node.className = "bubble deleted";
    node.innerHTML = "🚫 This message was deleted";

    const reactionsDiv = node.parentElement.querySelector('.reactions');
    if (reactionsDiv) {
      reactionsDiv.remove();
    }
  }

  console.log("✅ Message deleted:", messageId);
}

// TYPING INDICATOR
function handleSignal(signal) {
  try {
    if (signal.type === "typing" && signal.user !== state.user.name) {
      state.typingUsers.add(signal.displayName);
      updateTypingIndicator();

      setTimeout(() => {
        state.typingUsers.delete(signal.displayName);
        updateTypingIndicator();
      }, 3000);
    }

    if (signal.type === "stopped_typing") {
      state.typingUsers.delete(signal.displayName);
      updateTypingIndicator();
    }
  } catch (error) {
    console.error("❌ Signal handler error:", error);
  }
}

function updateTypingIndicator() {
  if (state.typingUsers.size === 0) {
    el.typing.textContent = "";
    el.typing.classList.remove("active");
    return;
  }

  const names = Array.from(state.typingUsers);
  el.typing.classList.add("active");

  if (names.length === 1) {
    el.typing.textContent = `${names[0]} is typing...`;
  } else if (names.length === 2) {
    el.typing.textContent = `${names[0]} and ${names[1]} are typing...`;
  } else {
    el.typing.textContent = `${names.length} people are typing...`;
  }
}

// REACTIONS SYSTEM
function handleReaction(reaction) {
  try {
    const { messageId, emoji, user, action } = reaction;

    if (!state.messageReactions.has(messageId)) {
      state.messageReactions.set(messageId, new Map());
    }

    const msgReactions = state.messageReactions.get(messageId);

    if (action === "add") {
      if (!msgReactions.has(emoji)) {
        msgReactions.set(emoji, new Set());
      }
      msgReactions.get(emoji).add(user);
    } else if (action === "remove") {
      if (msgReactions.has(emoji)) {
        msgReactions.get(emoji).delete(user);
        if (msgReactions.get(emoji).size === 0) {
          msgReactions.delete(emoji);
        }
      }
    }

    updateReactionsDisplay(messageId);
  } catch (error) {
    console.error("❌ Reaction handler error:", error);
  }
}

function updateReactionsDisplay(messageId) {
  const msgElement = el.messages.querySelector(`[data-id="${messageId}"]`);
  if (!msgElement) return;

  let reactionsDiv = msgElement.querySelector('.reactions');
  if (reactionsDiv) {
    reactionsDiv.remove();
  }

  const reactions = state.messageReactions.get(messageId);
  if (!reactions || reactions.size === 0) return;

  reactionsDiv = document.createElement('div');
  reactionsDiv.className = 'reactions';

  reactions.forEach((users, emoji) => {
    if (users.size > 0) {
      const reactionBtn = document.createElement('button');
      reactionBtn.className = 'reaction';
      reactionBtn.innerHTML = `${emoji} ${users.size}`;

      if (users.has(state.user.name)) {
        reactionBtn.classList.add('reacted');
      }

      reactionBtn.onclick = () => {
        toggleReaction(messageId, emoji);
      };

      reactionsDiv.appendChild(reactionBtn);
    }
  });

  const bubble = msgElement.querySelector('.bubble');
  bubble.appendChild(reactionsDiv);
}

function toggleReaction(messageId, emoji) {
  const reactions = state.messageReactions.get(messageId);
  const hasReacted = reactions && reactions.has(emoji) && reactions.get(emoji).has(state.user.name);

  const reaction = {
    messageId,
    emoji,
    user: state.user.name,
    action: hasReacted ? "remove" : "add",
    timestamp: Date.now()
  };

  state.pubnub.publish({
    channel: CHANNEL_REACTIONS,
    message: reaction
  }).catch(error => {
    console.error("❌ Failed to send reaction:", error);
  });
}

// READ RECEIPTS
function sendReceipt(messageId, type) {
  const receipt = {
    messageId,
    type,
    user: state.user.name,
    timestamp: Date.now()
  };

  state.pubnub.publish({
    channel: CHANNEL_RECEIPTS,
    message: receipt
  }).catch(error => {
    console.error("❌ Failed to send receipt:", error);
  });
}

function handleReceipt(receipt) {
  try {
    const { messageId, type, user } = receipt;

    if (!state.readReceipts.has(messageId)) {
      state.readReceipts.set(messageId, { delivered: new Set(), read: new Set() });
    }

    const msgReceipts = state.readReceipts.get(messageId);

    if (type === "delivered") {
      msgReceipts.delivered.add(user);
    } else if (type === "read") {
      msgReceipts.read.add(user);
    }

    updateReceiptDisplay(messageId);
  } catch (error) {
    console.error("❌ Receipt handler error:", error);
  }
}

function updateReceiptDisplay(messageId) {
  const msgElement = el.messages.querySelector(`[data-id="${messageId}"] .checks`);
  if (!msgElement) return;

  const receipts = state.readReceipts.get(messageId);
  if (!receipts) return;

  if (receipts.read.size > 0) {
    msgElement.className = "checks read";
    msgElement.textContent = "✓✓";
  } else if (receipts.delivered.size > 0) {
    msgElement.className = "checks delivered";
    msgElement.textContent = "✓✓";
  } else {
    msgElement.className = "checks sent";
    msgElement.textContent = "✓";
  }
}

// INTERSECTION OBSERVER FOR READ RECEIPTS
const messageObserver = new IntersectionObserver((entries) => {
  entries.forEach(entry => {
    if (entry.isIntersecting) {
      const msgId = entry.target.dataset.id;
      const msg = state.messages.get(msgId);

      if (msg && msg.name !== state.user.name && !msg.readBySelf) {
        msg.readBySelf = true;
        sendReceipt(msgId, "read");
      }
    }
  });
}, { threshold: 0.5 });

// INPUT HANDLING WITH SPAM CONTROL
el.input.addEventListener("input", () => {
  el.send.disabled = !el.input.value.trim();
  el.input.style.height = "auto";
  el.input.style.height = Math.min(el.input.scrollHeight, 130) + "px";

  clearTimeout(state.typingTimer);

  const now = Date.now();
  if (now - state.lastTypingSignal > 2000 && state.connected) {
    state.pubnub.publish({
      channel: CHANNEL_SIGNALS,
      message: {
        type: "typing",
        user: state.user.name,
        displayName: state.user.displayName,
        timestamp: now
      }
    }).catch(() => {});
    state.lastTypingSignal = now;
  }

  state.typingTimer = setTimeout(() => {
    if (state.connected) {
      state.pubnub.publish({
        channel: CHANNEL_SIGNALS,
        message: {
          type: "stopped_typing",
          user: state.user.name
        }
      }).catch(() => {});
    }
  }, 3000);
});

function loadHistory() {
  state.pubnub.fetchMessages({ 
    channels: [CHANNEL], 
    count: 50
  })
  .then(response => {
    const msgs = (response.channels[CHANNEL] || [])
      .map(e => {
        const msg = e.message;
        if (msg && msg.id && msg.txt) {
          msg.timetoken = e.timetoken;
          return msg;
        }
        return null;
      })
      .filter(m => m !== null);

    console.log("📥 Loaded", msgs.length, "messages");
    msgs.forEach(m => renderMessage(m, false));

    if (state.settings.autoScroll) {
      el.messages.scrollTop = el.messages.scrollHeight;
    }
  })
  .catch(error => {
    console.error("❌ History error:", error);
  });
}

function loadDeleteHistory() {
  state.pubnub.fetchMessages({ 
    channels: [CHANNEL_DELETE], 
    count: 100
  })
  .then(response => {
    const deletes = (response.channels[CHANNEL_DELETE] || [])
      .map(e => e.message)
      .filter(m => m && m.id);

    console.log("📥 Loaded", deletes.length, "delete events");

    deletes.forEach(d => {
      handleDelete(d.id);
    });
  })
  .catch(error => {
    console.error("❌ Delete history error:", error);
  });
}

function loadReactions() {
  state.pubnub.fetchMessages({ 
    channels: [CHANNEL_REACTIONS], 
    count: 100
  })
  .then(response => {
    const reactions = (response.channels[CHANNEL_REACTIONS] || [])
      .map(e => e.message)
      .filter(m => m && m.messageId);

    console.log("📥 Loaded", reactions.length, "reactions");

    reactions.forEach(r => {
      handleReaction(r);
    });
  })
  .catch(error => {
    console.error("❌ Reactions history error:", error);
  });
}

function dayLabel(ts) {
  const d = new Date(ts);
  const t = new Date();
  const y = new Date(t);
  y.setDate(t.getDate() - 1);

  if (d.toDateString() === t.toDateString()) return "Today";
  if (d.toDateString() === y.toDateString()) return "Yesterday";

  return d.toLocaleDateString("en-US", {
    month: "short",
    day: "numeric",
    year: d.getFullYear() !== t.getFullYear() ? "numeric" : undefined
  });
}

function needDivider(curr, prev) {
  if (!prev) return true;
  return new Date(curr).toDateString() !== new Date(prev).toDateString();
}

function insertDivider(ts) {
  const div = document.createElement("div");
  div.className = "date-divider";
  div.innerHTML = `<div class="date-label">${dayLabel(ts)}</div>`;
  el.messages.appendChild(div);
}

function extractLinks(text) {
  const urlRegex = /(https?:\/\/[^\s]+)/g;
  return text.match(urlRegex) || [];
}

function createLinkPreview(url) {
  try {
    const urlObj = new URL(url);
    const domain = urlObj.hostname.replace('www.', '');

    const preview = document.createElement('div');
    preview.className = 'link-preview';
    preview.innerHTML = `
      <svg class="link-icon" viewBox="0 0 24 24" fill="currentColor">
        <path d="M19 19H5V5h7V3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14c1.1 0 2-.9 2-2v-7h-2v7zM14 3v2h3.59l-9.83 9.83 1.41 1.41L19 6.41V10h2V3h-7z"/>
      </svg>
      <div>
        <div class="link-domain">${domain}</div>
        <div style="font-size: 12px; opacity: 0.7;">${url.length > 40 ? url.substring(0, 40) + '...' : url}</div>
      </div>
    `;

    preview.onclick = (e) => {
      e.stopPropagation();
      window.open(url, '_blank');
    };

    return preview;
  } catch (error) {
    return null;
  }
}

function renderMessage(msg, animate) {
  try {
    if (!msg || !msg.id || !msg.txt || state.messages.has(msg.id)) return;

    const isDeleted = state.deletedIds.has(msg.id);
    if (isDeleted) {
      msg.deleted = true;
    }

    const lastMsg = [...state.messages.values()].pop();
    if (needDivider(msg.ts, lastMsg?.ts)) insertDivider(msg.ts);

    state.messages.set(msg.id, msg);

    const isMe = msg.name === state.user?.name;
    const wrapper = document.createElement("div");
    wrapper.className = `msg ${isMe ? "me" : "you"}`;
    wrapper.dataset.id = msg.id;

    const bubble = document.createElement("div");
    bubble.className = msg.deleted ? "bubble deleted" : "bubble";

    // REPLY PREVIEW
    if (msg.reply && !msg.deleted) {
      const replyDiv = document.createElement("div");
      replyDiv.className = "reply-preview";
      replyDiv.innerHTML = `<div class="reply-name">${msg.reply.displayName}</div><div class="reply-text">${msg.reply.txt}</div>`;

      replyDiv.onclick = (e) => {
        e.stopPropagation();
        jumpToMessage(msg.reply.id);
      };

      bubble.appendChild(replyDiv);
    }

    // MESSAGE CONTENT
    const textDiv = document.createElement("div");
    textDiv.textContent = msg.deleted ? "🚫 This message was deleted" : msg.txt;

    bubble.appendChild(textDiv);

    // LINK PREVIEW
    if (!msg.deleted) {
      const links = extractLinks(msg.txt);
      if (links.length > 0) {
        const linkPreview = createLinkPreview(links[0]);
        if (linkPreview) {
          bubble.appendChild(linkPreview);
        }
      }
    }

    // TIME + CHECKMARKS
    const timeDiv = document.createElement("div");
    timeDiv.className = "msg-time";
    timeDiv.textContent = new Date(msg.ts).toLocaleTimeString("en-US", {
      hour: "numeric",
      minute: "2-digit"
    });

    if (isMe && !msg.deleted) {
      const checks = document.createElement("span");
      checks.className = "checks sent";
      checks.textContent = "✓";
      timeDiv.appendChild(checks);
    }

    bubble.appendChild(timeDiv);

    wrapper.appendChild(bubble);

    const wasAtBottom = el.messages.scrollTop + el.messages.clientHeight >= el.messages.scrollHeight - 10;

    el.messages.appendChild(wrapper);

    if (!isMe) {
      messageObserver.observe(wrapper);
    }

    if (animate) {
      if (wasAtBottom && state.settings.autoScroll) {
        el.messages.scrollTop = el.messages.scrollHeight;
      } else if (!wasAtBottom) {
        showNewMessagesBadge();
      }
    }

    // CONTEXT MENU
    if (!msg.deleted) {
      bubble.addEventListener("contextmenu", e => {
        e.preventDefault();
        showMenu(e.clientX, e.clientY, msg, isMe);
      });

      let touchTimer;
      bubble.addEventListener("touchstart", e => {
        touchTimer = setTimeout(() => {
          showMenu(e.touches[0].clientX, e.touches[0].clientY, msg, isMe);
        }, 500);
      });
      bubble.addEventListener("touchend", () => clearTimeout(touchTimer));
    }

    updateReactionsDisplay(msg.id);

    if (isMe) {
      updateReceiptDisplay(msg.id);
    }

  } catch (error) {
    console.error("❌ Render message error:", error);
  }
}

function showNewMessagesBadge() {
  let badge = el.messages.querySelector('.new-messages-badge');
  if (!badge) {
    badge = document.createElement('div');
    badge.className = 'new-messages-badge';
    badge.textContent = 'New messages ↓';
    badge.onclick = () => {
      el.messages.scrollTop = el.messages.scrollHeight;
      badge.remove();
    };
    el.messages.appendChild(badge);
  }
}

function jumpToMessage(messageId) {
  const msgElement = el.messages.querySelector(`[data-id="${messageId}"]`);
  if (msgElement) {
    msgElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
    msgElement.classList.add('highlighted');
    setTimeout(() => {
      msgElement.classList.remove('highlighted');
    }, 2000);
  }
}

function showMenu(x, y, msg, isMe) {
  state.currentMenuMessage = msg;

  el.menu.style.left = Math.min(x, window.innerWidth - 180) + "px";
  el.menu.style.top = Math.min(y, window.innerHeight - 200) + "px";
  el.menu.classList.add("show");

  // Only show delete for own messages
  el.mDelete.style.display = isMe ? "flex" : "none";
}

document.addEventListener("click", () => {
  el.menu.classList.remove("show");
  el.emojiPicker.classList.remove("show");
});

// MENU ACTIONS
el.mReply.onclick = () => {
  const msg = state.currentMenuMessage;
  if (!msg) return;

  state.replyTo = msg;
  el.replyName.textContent = msg.displayName;
  el.replyText.textContent = msg.txt;
  el.replyBar.classList.add("show");
  el.input.focus();
};

el.mCopy.onclick = async () => {
  const msg = state.currentMenuMessage;
  if (!msg) return;

  try {
    await navigator.clipboard.writeText(msg.txt);
    notify("✅ Message copied!");
  } catch (error) {
    const textArea = document.createElement('textarea');
    textArea.value = msg.txt;
    document.body.appendChild(textArea);
    textArea.select();
    document.execCommand('copy');
    document.body.removeChild(textArea);
    notify("✅ Message copied!");
  }
};

el.mReact.onclick = () => {
  el.emojiPicker.classList.add("show");
};

el.mDelete.onclick = () => {
  const msg = state.currentMenuMessage;
  if (!msg || msg.name !== state.user.name) {
    notify("❌ Can only delete your own messages");
    return;
  }

  el.deleteDialog.classList.add("show");
  el.deleteDialog.dataset.id = msg.id;
};

// EMOJI PICKER
document.querySelectorAll('.emoji-btn').forEach(btn => {
  btn.onclick = () => {
    const msg = state.currentMenuMessage;
    if (msg) {
      toggleReaction(msg.id, btn.textContent);
      el.emojiPicker.classList.remove("show");
    }
  };
});

el.dialogDeleteCancel.onclick = () => el.deleteDialog.classList.remove("show");

el.dialogDeleteConfirm.onclick = () => {
  const messageId = el.deleteDialog.dataset.id;
  const msg = state.messages.get(messageId);

  if (!msg || msg.name !== state.user.name) {
    notify("❌ Can only delete your own messages");
    el.deleteDialog.classList.remove("show");
    return;
  }

  state.pubnub.publish({
    channel: CHANNEL_DELETE,
    message: { 
      id: messageId,
      deletedBy: state.user.name,
      deletedAt: Date.now()
    },
    storeInHistory: true
  }).then(() => {
    console.log("✅ Delete published");
    el.deleteDialog.classList.remove("show");
    notify("🗑️ Message deleted");
  }).catch(error => {
    console.error("❌ Delete failed:", error);
    notify("❌ Failed to delete message");
  });
};

el.input.addEventListener("keydown", e => {
  if (e.key === "Enter" && e.shiftKey) {
    e.preventDefault();
    send();
  }
});

el.send.onclick = send;

el.replyClose.onclick = () => {
  state.replyTo = null;
  el.replyBar.classList.remove("show");
};

// SEND WITH SPAM CONTROL
function send() {
  const txt = el.input.value.trim();

  if (!txt || !state.connected) {
    if (!state.connected) notify("❌ Not connected");
    return;
  }

  const now = Date.now();
  if (now - state.lastSendTime < 500) {
    notify("⚠️ Slow down! Too fast.");
    return;
  }
  state.lastSendTime = now;

  if (state.connected) {
    state.pubnub.publish({
      channel: CHANNEL_SIGNALS,
      message: {
        type: "stopped_typing",
        user: state.user.name
      }
    }).catch(() => {});
  }
  clearTimeout(state.typingTimer);

  const msg = {
    id: Date.now() + "-" + Math.random().toString(36).slice(2, 9),
    txt: txt,
    ts: Date.now(),
    name: state.user.name,
    displayName: state.user.displayName
  };

  if (state.replyTo) {
    msg.reply = {
      id: state.replyTo.id,
      txt: state.replyTo.txt,
      displayName: state.replyTo.displayName
    };
    state.replyTo = null;
    el.replyBar.classList.remove("show");
  }

  el.send.disabled = true;

  state.pubnub.publish({
    channel: CHANNEL,
    message: msg
  })
  .then(() => {
    console.log("✅ Message sent");
    el.input.value = "";
    el.input.style.height = "auto";
    setTimeout(() => el.send.disabled = !el.input.value.trim(), 100);
  })
  .catch(error => {
    console.error("❌ Send failed:", error);
    notify("❌ Failed to send message");
    el.send.disabled = false;
  });
}

// SETTINGS
el.themeToggle.onclick = () => {
  state.settings.darkMode = !state.settings.darkMode;
  el.themeToggle.classList.toggle("active", state.settings.darkMode);
  document.body.classList.toggle("dark", state.settings.darkMode);
  localStorage.setItem("settings", JSON.stringify(state.settings));
  notify(state.settings.darkMode ? "🌙 Dark mode" : "☀️ Light mode");
};

el.logoutBtn.onclick = () => {
  el.logoutDialog.classList.add("show");
};

el.dialogLogoutCancel.onclick = () => {
  el.logoutDialog.classList.remove("show");
};

el.dialogLogoutConfirm.onclick = () => {
  if (state.pubnub) {
    state.pubnub.unsubscribeAll();
    state.pubnub = null;
  }
  localStorage.removeItem("chatUser");
  location.reload();
};

el.settingsBtn.onclick = () => {
  el.settingsDialog.classList.add("show");
};

el.dialogSettingsClose.onclick = () => {
  el.settingsDialog.classList.remove("show");
};

el.soundToggle.onclick = () => {
  state.settings.sound = !state.settings.sound;
  el.soundToggle.classList.toggle("active", state.settings.sound);
  localStorage.setItem("settings", JSON.stringify(state.settings));
};

el.notifToggle.onclick = () => {
  state.settings.notifications = !state.settings.notifications;
  el.notifToggle.classList.toggle("active", state.settings.notifications);
  localStorage.setItem("settings", JSON.stringify(state.settings));
};

el.pushToggle.onclick = async () => {
  state.settings.pushNotifications = !state.settings.pushNotifications;
  el.pushToggle.classList.toggle("active", state.settings.pushNotifications);

  if (state.settings.pushNotifications) {
    const granted = await requestNotificationPermission();
    if (!granted) {
      state.settings.pushNotifications = false;
      el.pushToggle.classList.remove("active");
    }
  }

  localStorage.setItem("settings", JSON.stringify(state.settings));
};

el.scrollToggle.onclick = () => {
  state.settings.autoScroll = !state.settings.autoScroll;
  el.scrollToggle.classList.toggle("active", state.settings.autoScroll);
  localStorage.setItem("settings", JSON.stringify(state.settings));
};

el.openColorDialog.onclick = () => {
  el.colorDialog.classList.add("show");
};

el.dialogColorCancel.onclick = () => {
  el.colorDialog.classList.remove("show");
};

document.querySelectorAll(".color-option").forEach(opt => {
  opt.onclick = () => {
    document.querySelectorAll(".color-option").forEach(o => o.classList.remove("selected"));
    opt.classList.add("selected");
    state.settings.accentColor = opt.dataset.color;
  };
});

el.dialogColorApply.onclick = () => {
  document.body.dataset.accent = state.settings.accentColor;
  localStorage.setItem("settings", JSON.stringify(state.settings));
  el.colorDialog.classList.remove("show");
  notify("✅ Color changed");
};

function notify(text) {
  el.notification.textContent = text;
  el.notification.classList.add("show");
  setTimeout(() => el.notification.classList.remove("show"), 3000);
}

// RESTORE SESSION
window.addEventListener("load", () => {
  try {
    const saved = localStorage.getItem("chatUser");
    if (saved) {
      const user = JSON.parse(saved);
      if (ALLOWED.includes(user.name)) {
        CONFIG.uuid = user.name;
        login(user.name);
      }
    }

    const savedSettings = localStorage.getItem("settings");
    if (savedSettings) {
      Object.assign(state.settings, JSON.parse(savedSettings));
      el.soundToggle.classList.toggle("active", state.settings.sound);
      el.notifToggle.classList.toggle("active", state.settings.notifications);
      el.pushToggle.classList.toggle("active", state.settings.pushNotifications);
      el.scrollToggle.classList.toggle("active", state.settings.autoScroll);
      el.themeToggle.classList.toggle("active", state.settings.darkMode);
      document.body.classList.toggle("dark", state.settings.darkMode);
      document.body.dataset.accent = state.settings.accentColor;
    }
  } catch (e) {
    console.error("Session restore error:", e);
  }
});

console.log("✅ Chat-APP Pro v4.1 - Ready!");
</script>

</body>
</html>
